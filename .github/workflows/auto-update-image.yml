name: Auto-update easyengine-docker
permissions:
  contents: write
  actions: read

on:
  schedule:
    - cron: '30 21 * * *' # Chạy định kỳ lúc 3:00 AM giờ Ấn Độ (IST) mỗi ngày
  workflow_dispatch:      # Cho phép bấm nút chạy thủ công để test

jobs:
  automation-pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Orchestrator (Docker Repo)
        uses: actions/checkout@v4
        with:
          path: main-docker

      # 1. KIỂM TRA PHIÊN BẢN MỚI TỪ EASYENGINE GỐC (NHÁNH DEVELOP)
      - name: Check for New Version
        id: check_version
        run: |
          # Lấy version từ dự án gốc EasyEngine
          REMOTE=$(curl -s https://raw.githubusercontent.com/EasyEngine/easyengine/develop/VERSION | xargs)
          # Lấy version hiện tại trong repo docker của bạn
          LOCAL=$(cat main-docker/VERSION | xargs)
          
          if [ "$REMOTE" = "$LOCAL" ]; then
            echo "Version is up to date ($REMOTE). Skipping..."
            echo "run=false" >> $GITHUB_OUTPUT
          else
            echo "New version detected: $REMOTE"
            echo "run=true" >> $GITHUB_OUTPUT
            echo "ver=$REMOTE" >> $GITHUB_OUTPUT
          fi

      - name: Setup Git Config
        if: steps.check_version.outputs.run == 'true'
        run: |
          git config --global user.name "EE-Update-Bot"
          git config --global user.email "bot@github.com"

      # 2. XỬ LÝ SITE-COMMAND (PATCH HÀM TỪ FILE TEMPLATE .TXT)
      - name: Sync & Patch Site-Command
        if: steps.check_version.outputs.run == 'true'
        run: |
          git clone https://x-access-token:${{ secrets.EE_DOCKER_AUTO_UPDATE_TOKEN }}@github.com/dinhngocdung/site-command.git sc
          cd sc
          git remote add upstream https://github.com/EasyEngine/site-command.git
          git fetch upstream
          git reset --hard upstream/develop
          
          # Dùng PHP để patch: đọc nội dung từ templates/site-utils-patch.txt
          php -r '
            $file = "src/helper/site-utils.php";
            $content = file_get_contents($file);
            $patch = file_get_contents("../main-docker/templates/site-utils-patch.txt");
            
            // 1. Tìm vị trí bắt đầu của hàm cần thay thế
            $functionName = "function remove_etc_hosts_entry";
            $startPos = strpos($content, $functionName);
            
            if ($startPos === false) {
                echo "Error: Function not found.\n"; exit(1);
            }

            // 2. Tìm ngược lên trên để lấy phần DocBlock (ghi chú /**)
            $docBlockPos = strrpos(substr($content, 0, $startPos), "/**");
            
            // 3. Tìm dấu đóng ngoặc nhọn "}" cuối cùng của hàm đó
            // Chúng ta tìm dấu } đầu tiên sau vị trí hàm
            $endPos = strpos($content, "}", $startPos) + 1;

            // 4. Thực hiện thay thế đoạn từ $docBlockPos đến $endPos
            $before = substr($content, 0, $docBlockPos);
            $after = substr($content, $endPos);
            
            $updated = $before . $patch . $after;
            
            file_put_contents($file, $updated);
            echo "Patch applied precisely.\n";
          '
          git add .
          git commit -m "Auto-patch v${{ steps.check_version.outputs.ver }}: Docker compatibility [skip ci]"
          git push origin develop --force

      # 3. XỬ LÝ EASYENGINE (PATCH COMPOSER & BUILD PHAR)
      - name: Sync & Patch EasyEngine
        if: steps.check_version.outputs.run == 'true'
        env:
          GH_TOKEN: ${{ secrets.EE_DOCKER_AUTO_UPDATE_TOKEN }}
        run: |
          set -euo pipefail

          git clone https://x-access-token:${GH_TOKEN}@github.com/dinhngocdung/easyengine.git ee
          cd ee
          git remote add upstream https://github.com/EasyEngine/easyengine.git
          git fetch upstream
          git reset --hard upstream/develop
          
          # Chép file workflow build phar từ template
          mkdir -p .github/workflows
          cp ../main-docker/templates/build.yml .github/workflows/build.yml
          
          # Merge composer-patch.json vào file gốc
          jq -s '.[0] * .[1]' composer.json ../main-docker/templates/composer-patch.json > tmp.json && mv tmp.json composer.json
          
          git add .
          git commit -m "Auto-sync v${{ steps.check_version.outputs.ver }}: Apply custom build config [skip ci]"
          git push origin develop --force
          
          # Đợi build PHAR tại repo easyengine xong mới đi tiếp
          OWNER="dinhngocdung"
          REPO="easyengine"
          WORKFLOW_FILE="build.yml"
          REF="develop"
          API="https://api.github.com"
          TOKEN="$GH_TOKEN"

          start_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "Dispatching workflow $WORKFLOW_FILE on $OWNER/$REPO@$REF (start_time=$start_time)..."

          # Trigger workflow_dispatch
          curl -s -X POST \
            -H "Authorization: token $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "$API/repos/$OWNER/$REPO/actions/workflows/$WORKFLOW_FILE/dispatches" \
            -d "{\"ref\":\"$REF\"}"

          echo "Waiting for a workflow run to be created..."
          # Find the run id that has head_branch == REF and created_at > start_time
          run_id=""
          for i in {1..60}; do        # ~ up to 10 minutes (60*10s); điều chỉnh nếu muốn
            sleep 10
            runs_json=$(curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
              "$API/repos/$OWNER/$REPO/actions/runs?event=workflow_dispatch&per_page=50")
            run_id=$(echo "$runs_json" | jq -r --arg ref "$REF" --arg start "$start_time" \
              '.workflow_runs[] | select(.head_branch == $ref and .created_at > $start) | .id' | head -n1)

            if [ -n "$run_id" ] && [ "$run_id" != "null" ]; then
              echo "Found run id: $run_id"
              break
            fi
            echo "No run yet, retrying... ($i)"
          done

          if [ -z "$run_id" ] || [ "$run_id" = "null" ]; then
            echo "Timed out waiting for workflow run to be created."
            exit 1
          fi

          # Poll the run status until completed
          echo "Polling run $run_id status..."
          while true; do
            sleep 10
            run_info=$(curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
              "$API/repos/$OWNER/$REPO/actions/runs/$run_id")
            status=$(echo "$run_info" | jq -r .status)
            conclusion=$(echo "$run_info" | jq -r .conclusion)
            echo "Status: $status, Conclusion: $conclusion"

            if [ "$status" = "completed" ]; then
              if [ "$conclusion" = "success" ]; then
                echo "Workflow completed successfully."
                break
              else
                echo "Workflow completed with conclusion: $conclusion"
                exit 1
              fi
            fi
          done

      # 4. ĐỒNG BỘ VERSION VÀ BUILD DOCKER IMAGE (VÀ PUSH LÊN NHIỀU REGISTRY)
      - name: Finalize & Trigger Docker Build + Other Registries
        if: steps.check_version.outputs.run == 'true'
        env:
          GH_TOKEN: ${{ secrets.EE_DOCKER_AUTO_UPDATE_TOKEN }}
        run: |
          set -euo pipefail

          # Đồng bộ file VERSION thực tế từ EE sang Docker
          cp ee/VERSION main-docker/VERSION
          cd main-docker
          
          git add VERSION
          git commit -m "Bump version to $(cat VERSION)" || echo "No change in VERSION [skip ci]"

          # Ensure push uses the PAT provided in GH_TOKEN so it won't use github-actions[bot]
          git remote set-url origin https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
          git push origin main
          
          # Function-like helper (bash) để dispatch workflow và đợi hoàn tất
          dispatch_and_wait() {
            OWNER="$1"
            REPO="$2"
            WORKFLOW_FILE="$3"
            REF="$4"
            TOKEN="$5"
            API="https://api.github.com"

            start_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "Dispatching workflow $WORKFLOW_FILE on $OWNER/$REPO@$REF (start_time=$start_time)..."

            # Trigger workflow_dispatch and capture HTTP status + body
            tmp_body=$(mktemp)
            http_code=$(curl -s -o "$tmp_body" -w "%{http_code}" -X POST \
              -H "Authorization: token $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "$API/repos/$OWNER/$REPO/actions/workflows/$WORKFLOW_FILE/dispatches" \
              -d "{\"ref\":\"$REF\"}")

            echo "Dispatch HTTP code: $http_code"
            if [ "$http_code" -ne 204 ]; then
              echo "Dispatch response body:"
              cat "$tmp_body" || true
              rm -f "$tmp_body"
              echo "Dispatch failed (HTTP $http_code) for $WORKFLOW_FILE"
              return 3
            fi
            rm -f "$tmp_body"

            echo "Waiting for a workflow run to be created..."
            run_id=""
            for i in {1..90}; do
              sleep 10

              # Query runs for the specific workflow file (less noisy)
              runs_json=$(curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                "$API/repos/$OWNER/$REPO/actions/workflows/$WORKFLOW_FILE/runs?per_page=50")

              # Debug: print short summary (uncomment to see raw runs_json)
              echo "Runs JSON length: $(echo -n "$runs_json" | wc -c) chars"

              run_id=$(echo "$runs_json" | jq -r --arg ref "$REF" --arg start "$start_time" \
                '.workflow_runs[] | select(.head_branch == $ref and .created_at > $start) | .id' | head -n1)

              if [ -n "$run_id" ] && [ "$run_id" != "null" ]; then
                echo "Found run id: $run_id"
                break
              fi
              echo "No run yet, retrying... ($i)"
            done

            if [ -z "$run_id" ] || [ "$run_id" = "null" ]; then
              echo "Timed out waiting for workflow run to be created for $WORKFLOW_FILE."
              # For debugging, dump last runs_json
              echo "Last runs_json:"
              echo "$runs_json" | jq '.' || echo "$runs_json"
              return 1
            fi

            # Poll the run status until completed
            echo "Polling run $run_id status for $WORKFLOW_FILE..."
            while true; do
              sleep 10
              run_info=$(curl -s -H "Authorization: token $TOKEN" -H "Accept: application/vnd.github+json" \
                "$API/repos/$OWNER/$REPO/actions/runs/$run_id")
              status=$(echo "$run_info" | jq -r .status)
              conclusion=$(echo "$run_info" | jq -r .conclusion)
              echo "Status: $status, Conclusion: $conclusion"

              if [ "$status" = "completed" ]; then
                if [ "$conclusion" = "success" ]; then
                  echo "Workflow $WORKFLOW_FILE completed successfully."
                  return 0
                else
                  echo "Workflow $WORKFLOW_FILE completed with conclusion: $conclusion"
                  return 2
                fi
              fi
            done
          }

          # 4.a Dispatch docker.io publish (existing)
          dispatch_and_wait "dinhngocdung" "easyengine-docker" "docker.io-publish.yml" "main" "${GH_TOKEN}"
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "docker.io publish workflow failed or timed out (rc=$rc). Aborting."
            exit 1
          fi

          # 4.b Dispatch quay.io publish
          dispatch_and_wait "dinhngocdung" "easyengine-docker" "quay.io-publish.yml" "main" "${GH_TOKEN}"
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "quay.io publish workflow failed or timed out (rc=$rc). Aborting."
            exit 1
          fi

          # 4.c Dispatch ghcr publish
          dispatch_and_wait "dinhngocdung" "easyengine-docker" "ghcr.io-publish.yml" "main" "${GH_TOKEN}"
          rc=$?
          if [ $rc -ne 0 ]; then
            echo "ghcr.io publish workflow failed or timed out (rc=$rc). Aborting."
            exit 1
          fi

          echo "All registry publish workflows dispatched and completed successfully."
